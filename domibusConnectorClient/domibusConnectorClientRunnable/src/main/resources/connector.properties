# defines the endpoint address of the gateway webservice, the gateway name and role.
gateway.endpoint.address=
gateway.name=
gateway.role=

# As every nation has its own backend client, an implementation of the DomibusConnectorNationalBackendClient interface has to be implemented which handles the connection to its own backend.
# Here the full qualified name of the implementation class which implements DomibusConnectorNationalBackendClient must be given.
# If using the standalone connector the default implementation 'eu.domibus.connector.nbc.DomibusConnectorNationalBackendClientDefaultImpl' must be set here.
connector.national.backend.client.implementation.class.name=eu.domibus.connector.nbc.DomibusConnectorNationalBackendClientDefaultImpl

# defines if content mapper module should be used. 
# If there is a certain national format the eCodex message should be transformed to
# this content mapper handles the mapping. The main class DomibusConnectorContentMapperImpl has to be
# extended.
connector.use.content.mapper=false

# If content mapper module is used, an implementation of the DomibusConnectorContentMapper interface has to be implemented with national content.
# Here the full qualified name of the implementation class which implements DomibusConnectorContentMapper must be given.
# If no content mapper is used (connector.use.content.mappe set false), property can be left empty:
# property connector.content.mapper.implementation.class.name=
connector.content.mapper.implementation.class.name=

# defines if security toolkit should be used. 
# If messages should be encrypted with a trustOkToken and be sent in an encrypted container,
# this module has to be activated. 
connector.use.security.toolkit=true

connector.security.toolkit.implementation.class.name=

# defines if evidences toolkit should be used.
# In ebMS standard messages should be confirmed or declined by evidences messages sent back to the message sender.
# Those messages contain the state of the message sent and are therefore good to hold reliability.
connector.use.evidences.toolkit=true

# defines how often the gateway and the national backend system should be checked for messages.
# All messages in both directions should be handled entirely before next period starts. So no conflicts are produced.
# Value is in milliseconds. For seconds divide value with 1000. For example 30 000 milliseconds are 30 seconds.
connector.check.messages.period.ms=60000

# defines the timeout for RelayREMMD evidence to be sent back when an outgoing message was sent. 
# After this period, if an outgoing message was sent to the gateway successfully and no RelayREMMD evidence was received, 
# a RelayREMMDRejection will be created for this evidence an sent back to the national system.
# Value is in milliseconds. For seconds divide value with 1000. For hours divide value with 3600000.
connector.evidence.relayremmd.timeout.ms=86400000

connector.evidence.delivery.timeout.ms=86400000

connector.evidence.retrieval.timeout.ms=86400000

# boolean value to turn on/off the check if evidences for outgoing messages have been received yet.
connector.use.evidences.timeout=false

# Following properties define the connection to the database where message states should be logged.
# The dialect and driverClassName values depend on the dbms that is in use. Here some examples:
# Oracle:
connector.database.dialect=org.hibernate.dialect.Oracle10gDialect
connector.database.driverClassName=oracle.jdbc.driver.OracleDriver
# MySQL:
# connector.database.dialect=org.hibernate.dialect.MySQLDialect
# connector.database.driverClassName=com.mysql.jdbc.Driver
connector.database.url=
connector.database.username=
connector.database.password=

# To be able to sign evidences a keystore with certificate and private key integrated must be used. Here are the
# credentials to set.
connector.evidences.keystore.path=file:/private.jks
connector.evidences.keystore.password=
connector.evidences.key.alias=
connector.evidences.key.password=

# To be able to sign the secure contents of the message, a keystore with certificate and private key integrated must be used. Here are the
# credentials to set.
connector.security.keystore.path=file:/private.jks
connector.security.keystore.password=
connector.security.key.alias=
connector.security.key.password=

# A keystore with trusted, public certificates the security library checks received ASiC-S containers and "Trust Ok"-Tokens against. 
# If this property is set, signatures with certificates not being listed within the truststore will create an exception at the time of container/token-validation
# Do not set this properties to disable the check against a trusted certificate store.
java.truststore.path=file:/truststore.jks
java.truststore.password=

# The algorithm that is used to generate a hash value of the main document to be attached to the evidences. Values are: MD5, SHA1, SHA256
hash.algorithm=MD5

#HTTP and HTTPS proxy settings if necessary
http.proxy.enabled=false
http.proxy.host=
http.proxy.port=
http.proxy.user=
http.proxy.password=

# Settings for the security library for generating the Token.
token.issuer.country=
token.issuer.service.provider=
# This can rather be SIGNATURE_BASED, then the main document needs to be signed, or AUTHENTICATION_BASED, in that case the security interface needs 
# to be implemented (see connector.security.toolkit.implementation.class.name)
token.issuer.aes.value=SIGNATURE_BASED

# Address data for the generating of the evidences.
postal.address.street=
postal.address.locality=
postal.address.postal.code=
postal.address.country=

# database connection pool settings
c3p0.acquireIncrement=2
c3p0.minPoolSize=3
c3p0.maxPoolSize=5
c3p0.maxIdleTime=120


# new properties for dynamic discovery
connector.use.dynamic.discovery=false
dynamic.discovery.sml.resolver.address=localhost:5353
dynamic.discovery.community=civil-law
dynamic.discovery.environment=test
dynamic.discovery.normalisation.algorithm=MD5

# setting wether the connector is used clustered (with the same database) or not
connector.clustered=false

# defines the type of monitoring to be used. Implemented are JMX, REST and DB.
monitoring.type=DB


######################################################################################################################################################
######################################################## Runnable Connector specific properties ######################################################
######################################################################################################################################################

# full qualified path to the directory where the incoming messages should be stored. 
# Needs write privileges and also must be able to create sub directories.
incoming.messages.directory=

# full qualified path to the directory where the outgoing messages will be triggered at.
outgoing.messages.directory=

# every message has message properties in a file. This file can be named here. If not set, the default value 'message.properties' is used.
message.properties.file.name=
